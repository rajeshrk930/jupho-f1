import PDFDocument from 'pdfkit';
import { Analysis as PrismaAnalysis } from '@prisma/client';

export function generateAnalysisPDF(analysis: PrismaAnalysis): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];

    doc.on('data', (chunk: Buffer) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('Creative Analysis Report', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica').fillColor('#666666')
      .text(`Generated on ${new Date().toLocaleDateString()}`, { align: 'center' });
    
    doc.moveDown(2);

    // Creative Details Section
    doc.fontSize(14).font('Helvetica-Bold').fillColor('#000000').text('Creative Details');
    doc.moveDown(0.5);
    doc.fontSize(11).font('Helvetica');
    
    doc.text(`Objective: ${analysis.objective.replace('_', ' ')}`);
    doc.text(`Creative Type: ${analysis.creativeType}`);
    
    if (analysis.headline) {
      doc.moveDown(0.5);
      doc.text(`Headline: ${analysis.headline}`);
    }
    
    if (analysis.primaryText) {
      doc.moveDown(0.5);
      doc.text(`Primary Text: ${analysis.primaryText}`);
    }

    doc.moveDown(1.5);

    // Metrics Section
    doc.fontSize(14).font('Helvetica-Bold').text('Performance Metrics');
    doc.moveDown(0.5);
    doc.fontSize(11).font('Helvetica');
    
    const metrics = [];
    if (typeof analysis.cpm === 'number') metrics.push(`CPM: $${analysis.cpm.toFixed(2)}`);
    if (typeof analysis.ctr === 'number') metrics.push(`CTR: ${analysis.ctr.toFixed(2)}%`);
    if (typeof analysis.cpa === 'number') metrics.push(`CPA: $${analysis.cpa.toFixed(2)}`);
    
    if (metrics.length > 0) {
      doc.text(metrics.join('  |  '));
    } else {
      doc.text('No metrics provided');
    }

    doc.moveDown(1.5);

    // Analysis Result Section
    doc.fontSize(14).font('Helvetica-Bold').text('Analysis Result');
    doc.moveDown(0.5);

    // Result Type Badge
    const resultColors: Record<string, string> = {
      DEAD: '#dc2626',
      AVERAGE: '#f59e0b',
      WINNING: '#16a34a'
    };
    doc.fontSize(12).font('Helvetica-Bold')
      .fillColor(resultColors[analysis.resultType] || '#666666')
      .text(`Status: ${analysis.resultType}`);
    
    doc.moveDown(1);

    // Primary Reason
    doc.fontSize(12).font('Helvetica-Bold').fillColor('#000000').text('Primary Reason:');
    doc.moveDown(0.3);
    doc.fontSize(11).font('Helvetica').text(analysis.primaryReason);

    doc.moveDown(1);

    // Supporting Logic
    doc.fontSize(12).font('Helvetica-Bold').text('Supporting Logic:');
    doc.moveDown(0.3);
    doc.fontSize(11).font('Helvetica');

    const logic = Array.isArray(analysis.supportingLogic)
      ? analysis.supportingLogic
      : analysis.supportingLogic
      ? (() => {
          try {
            const parsed = JSON.parse(analysis.supportingLogic as unknown as string);
            return Array.isArray(parsed) ? parsed : [String(analysis.supportingLogic)];
          } catch {
            return [String(analysis.supportingLogic)];
          }
        })()
      : [];

    if (!logic.length) {
      doc.text('No supporting points provided');
    } else {
      logic.forEach((point: string) => {
        doc.text(`â€¢ ${point}`);
      });
    }

    doc.moveDown(1);

    // Single Fix
    doc.fontSize(12).font('Helvetica-Bold').fillColor('#2563eb').text('Recommended Fix:');
    doc.moveDown(0.3);
    doc.fontSize(11).font('Helvetica').fillColor('#000000').text(analysis.singleFix);

    doc.moveDown(2);

    // Footer
    doc.fontSize(9).fillColor('#999999')
      .text('Generated by Creative Failure Analyzer', { align: 'center' });

    doc.end();
  });
}
